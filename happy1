
import sys, os, gc, time, asyncio, cv2, torch, numpy as np, serial_asyncio, mss
from ultralytics import YOLO
from qasync import QEventLoop
from PyQt5.QtCore import Qt, QTimer 
from PyQt5.QtGui import QImage, QPixmap 
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QLabel, QPushButton, QTextEdit, QInputDialog, QGroupBox,
    QVBoxLayout, QHBoxLayout, QFormLayout, QScrollArea, QComboBox, QSizePolicy, QLineEdit, QMessageBox, QTabWidget,
    QAction, QMenu, QSplashScreen, QGridLayout, QFileDialog, QCheckBox
)
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from datetime import datetime
import matplotlib.pyplot as plt
import csv, random, math, pandas as pd, numpy as np
from matplotlib.backends.backend_pdf import PdfPages

model = YOLO("C:\\Users\\Mai\\Desktop\\wafer_project\\redline.pt") # best.pt check
FRAME_WIDTH, FRAME_HEIGHT = 1280, 720
Target_Point = [FRAME_WIDTH // 2, FRAME_HEIGHT // 2]
default_dxdy = (556, 188)
TOLERANCE_PX, TOLERANCE_R = 1, 1
PIXEL_TO_STEP = {'x': 33.0, 'y': 45.65}
MAX_STEPS = 32000
CAMERA_INDEX = 0
BAUDRATE = 9600
SERIAL_PORT = "COM5" #'Arduino IDE'들어가서 PORT 확인 필수
STABLE_REQUIRED = 3
FONT = cv2.FONT_HERSHEY_SIMPLEX
FONT_SCALE, FONT_THICKNESS = 0.6, 2
TEXT_COLOR = (255, 255, 255)
Target_degree, angle = 0, 0
angle_to_step, max_rotation_step = 1, 32000
random_x_min, random_x_max = 400, 800
random_y_min, random_y_max = 300, 500
random_angle_min, random_angle_max = 0, 360 
auto_loop_count = 0
CLASS_COLORS = {
    'F1': (0, 0, 50), 'F2': (0, 0, 100),
    'P100': (0, 0, 255), 'P111': (255, 0, 0),
}
detection_stats = {
    "P100": {"F1": [], "F2": [], "P100": [], "P111": []},
    "P111": {"F1": [], "F2": [], "P100": [], "P111": []}
}
confirmed_center = None
send_enabled = sending_command = awaiting_done = default_mode = False
stable_count = 0
last_sent_command = ""
setting_target_mode = force_send = auto_mode = False
wafer_type_override = None
has_f1 = has_f2 = False
fixed_f1_box = fixed_f2_box = None
corrected_box = []
position_done = False
rotation_done = False
RANDOM_MODE = False
position_accuracy_history = []
rotation_accuracy_history = []

def calculate_rotation_accuracy(angle_error_val, max_error=30):
    if angle_error_val <= 0.1:
        return 100.0
    elif angle_error_val >= max_error:
        return 0.0
    else:
        return round((1 - (angle_error_val / max_error)) * 100, 2)
    
# def caluclate_delta_accuracy(current_angle, target_angle, initial_error):
#     diff = (target_angle - current_angle + 540) % 360 - 180
#     current_error = abs(diff)
#     if initial_error == 0:
#         return 100.0
#     acc = (1 - current_error / initial_error) * 100
#     return max(0.0,min(100.0,acc)) # 0~100

def save_report(loop_results, save_path=None):
        now = time.strftime("%Y%m%d_%H%M%S")
        if save_path is None:
            save_path = f"Result_report_{now}.csv"
        columns = [
            "Loop", "Start Time", "End Time", "Wafer Type", "Mode",
            "Position Acc (%)", "ΔX (px)", "ΔY (px)", "Rotation Acc (%)", "Angle Err (°)",
            "P100_F1_Count", "P100_F2_Count", "P100_P100_Count", "P100_P111_Count",
            "P111_F1_Count", "P111_F2_Count", "P111_P100_Count", "P111_P111_Count"
        ]
        df = pd.DataFrame(loop_results, columns=columns)

        pos_acc_avg = df["Position Acc (%)"].mean()
        rot_acc_avg = df["Rotation Acc (%)"].mean()
        angle_err_avg = df["Angle Err (°)"].mean()
        mean_dx = df["ΔX (px)"].abs().mean()
        mean_dy = df["ΔY (px)"].abs().mean()
        mean_pos_err = (df["ΔX (px)"].abs() + df["ΔY (px)"].abs()).mean()
        total_loops = len(df)
        wafer_types = df["Wafer Type"].unique()
        mode = df["Mode"].iloc[0] if total_loops else ""
        start_time = df["Start Time"].iloc[0] if total_loops else ""
        end_time = df["End Time"].iloc[-1] if total_loops else ""

        # P100 정탐/오탐
        p100 = df[df["Wafer Type"] == "P100"]
        if not p100.empty:
            p100_true = p100["P100_P100_Count"].sum()
            p100_false = p100["P100_P111_Count"].sum()
            p100_total = p100_true + p100_false
            p100_precision = (p100_true / p100_total * 100) if p100_total > 0 else 0
            p100_false_rate = (p100_false / p100_total * 100) if p100_total > 0 else 0
        else:
            p100_precision = p100_false_rate = 0

        # P111 정탐/오탐
        p111 = df[df["Wafer Type"] == "P111"]
        if not p111.empty:
            p111_true = p111["P111_F1_Count"].sum()
            p111_false = p111["P111_P100_Count"].sum() + p111["P111_F2_Count"].sum()
            p111_total = p111_true + p111_false
            p111_precision = (p111_true / p111_total * 100) if p111_total > 0 else 0
            p111_false_rate = (p111_false / p111_total * 100) if p111_total > 0 else 0
        else:
            p111_precision = p111_false_rate = 0

        with open(save_path, "w", newline="", encoding="utf-8-sig") as f:
            writer = csv.writer(f)
            writer.writerow(["# Align Summary"])
            writer.writerow(["Opeation Date", now])
            writer.writerow(["Wafer Type", ", ".join(wafer_types)])
            writer.writerow(["Mode", mode])
            writer.writerow(["Total loop", total_loops])
            writer.writerow(["Avg Position Accuracy", f"{pos_acc_avg:.2f}%"])
            writer.writerow(["Avg Rotation Accuracy", f"{rot_acc_avg:.2f}%"])
            writer.writerow(["Avg Angle Err", f"{angle_err_avg:.2f}°"])
            writer.writerow(["Avg ΔX (px)", f"{mean_dx:.2f}"])
            writer.writerow(["Avg ΔY (px)", f"{mean_dy:.2f}"])
            writer.writerow(["Avg Coords Err (|ΔX|+|ΔY|, px)", f"{mean_pos_err:.2f}"])
            writer.writerow([f"P100 Correct(%)", f"{p100_precision:.2f}%"])
            writer.writerow([f"P100 Wrong(%)", f"{p100_false_rate:.2f}%"])
            writer.writerow([f"P111 Correct(%)", f"{p111_precision:.2f}%"])
            writer.writerow([f"P111 Wrong(%)", f"{p111_false_rate:.2f}%"])
            writer.writerow([])
            writer.writerow(["# ====== raw data ======"])
        df.to_csv(save_path, mode='a', index=False, encoding="utf-8-sig")
        return save_path

def make_report_graph_pdf(csv_path, pdf_path=None):
    raw_start = 0
    save_time = ""
    with open(csv_path, encoding="utf-8-sig") as f:
        lines = f.readlines()
        for i, line in enumerate(lines):
            if "Operation Date" in line:
                save_time = line.strip().split(",")[1].strip()
            if "raw data" in line:
                raw_start = i + 1
                break

    df = pd.read_csv(csv_path, skiprows=raw_start, encoding="utf-8-sig")

    p100 = df[df["Wafer Type"] == "P100"]
    p111 = df[df["Wafer Type"] == "P111"]

    if pdf_path is None:
        pdf_path = "report_graph_" + save_time.replace(":", "").replace("-", "").replace(" ", "_") + ".pdf"

    with PdfPages(pdf_path) as pdf:
        plt.figure(figsize=(8, 6))
        plt.plot(df["Loop"], df["Position Acc (%)"], marker='o', label="Position Acc(%)")
        plt.plot(df["Loop"], df["Rotation Acc (%)"], marker='s', label="Rotation Acc(%)")
        plt.title(f"Position/Rotation Accuracy by Loop ({save_time})")
        plt.xlabel("루프")
        plt.ylabel("정확도(%)")
        plt.ylim(0, 105)
        plt.legend()
        plt.grid(True)
        pdf.savefig()
        plt.close()

        plt.figure(figsize=(8, 6))
        p100_counts = [
            p100["P100_F1_Count"].sum(),
            p100["P100_F2_Count"].sum(),
            p100["P100_P100_Count"].sum(),
            p100["P100_P111_Count"].sum()
        ]
        p100_labels = ["F1", "F2", "P100", "P111(error)"]
        bars = plt.bar(p100_labels, p100_counts)
        bars[3].set_hatch("//")
        plt.title(f"P100 detection results ({save_time})")
        plt.ylabel("Count")
        for i, v in enumerate(p100_counts):
            plt.text(i, v + 0.5, str(int(v)), ha='center', va='bottom')
        pdf.savefig()
        plt.close()

        plt.figure(figsize=(8, 6))
        p111_f1 = p111["P111_F1_Count"].sum()
        p111_f2 = p111["P111_F2_Count"].sum()
        p111_p100 = p111["P111_P100_Count"].sum()
        p111_p111 = p111["P111_P111_Count"].sum()
        p111_labels = ["F1", "F2(오탐)", "P100(오탐)", "P111"]
        p111_counts = [p111_f1, p111_f2, p111_p100, p111_p111]
        bars2 = plt.bar(p111_labels, p111_counts)
        bars2[1].set_hatch("//")
        bars2[2].set_hatch("//")
        plt.title(f"P111 detection results ({save_time})")
        plt.ylabel("Count")
        for i, v in enumerate(p111_counts):
            plt.text(i, v + 0.5, str(int(v)), ha='center', va='bottom')
        pdf.savefig()
        plt.close()
    return pdf_path

def show_warning(self, title, message):
    warning = QMessageBox(self)
    warning.setIcon(QMessageBox.Warning)
    warning.setWindowTitle(title)
    warning.setText(message)
    warning.setStandardButtons(QMessageBox.Ok)
    warning.exec_()

def calculate_accuracy_px(target_point, center_point): # 수정, 델타x,y로 정확도 계산 수정, max_error_px 및 threshold_px 삭제
    dx = target_point[0] - center_point[0]
    dy = target_point[1] - center_point[1]
    error_distance = (dx ** 2 + dy ** 2) ** 0.5
    MAX_ERROR_PX = 30        
    PERFECT_THRESH_PX = 3.0   

    if error_distance <= PERFECT_THRESH_PX: 
        return 100.0
    elif error_distance >= MAX_ERROR_PX:
        return 0.0 
    else:
        return round((1 - (error_distance / MAX_ERROR_PX)) * 100, 2)

def log(msg, window):
    timestamp = datetime.now().strftime("[%H:%M:%S]")
    full_msg = f"{timestamp} {msg}" 
    if hasattr(window, 'log_window') and window.log_window:
        window.log_window.append_log(full_msg)

def compute_roundness(cnt):
    area = cv2.contourArea(cnt)
    perimeter = cv2.arcLength(cnt, True)
    if perimeter == 0:
        return 0
    return 4 * np.pi * area / (perimeter * perimeter)

def draw_yolo_boxes(frame, results):
    for box in results[0].boxes.data:
        x1, y1, x2, y2, conf, cls = box.tolist()
        class_name = results[0].names[int(cls)]
        if class_name not in ["F1", "F2"]:
            continue
        color = CLASS_COLORS.get(class_name, (0, 255, 0))
        cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), color, 2)
        label = f"{class_name}"
        ((tw, th), _) = cv2.getTextSize(label, FONT, FONT_SCALE, FONT_THICKNESS)
        cv2.rectangle(frame, (int(x1), int(y1 - th - 4)), (int(x1 + tw), int(y1)), color, -1)
        cv2.putText(frame, label, (int(x1), int(y1 - 4)), FONT, FONT_SCALE, TEXT_COLOR, FONT_THICKNESS)

def detect_yolo_center(frame):
    rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    results = model(rgb)
    for box in results[0].boxes.data:
        x1, y1, x2, y2, *_ = box.tolist()
        cx = int((x1 + x2) / 2)
        cy = FRAME_HEIGHT - int((y1 + y2) / 2)
        return (cx, cy)
    return None

def calculate_angle(pt1, pt2):
    dx = pt2[0] - pt1[0]
    dy = pt2[1] - pt1[1]
    raw = np.degrees(np.arctan2(dy, dx))
    if raw < 0:
        raw += 360
    return (180 - raw) % 360

def calculate_rotation(current_angle, target_angle):
    dR = (target_angle - current_angle + 360) % 360
    diR = 1
    stR = max(1, min(int(dR * angle_to_step), max_rotation_step))
    return diR, stR

def calculate_steps(from_point, to_point):
    dx = to_point[0] - from_point[0]
    dy = from_point[1] - to_point[1] 

    dx_steps = min(int(abs(dx) * PIXEL_TO_STEP['x']), MAX_STEPS)
    dy_steps = min(int(abs(dy) * PIXEL_TO_STEP['y']), MAX_STEPS)

    dix = 1 if dx > 0 else 0
    diy = 1 if dy > 0 else 0
    command = f"{dix},{diy},{dx_steps},{dy_steps},0,0"
    return dx, dy, dx_steps, dy_steps, command

class MainWindow(QMainWindow):
    def __init__(self, loop): 
        super().__init__() 
        self.loop = loop
        self.mode = "IDLE"
        self.setWindowTitle("Wafer_Aligner")
        self.setFixedSize(FRAME_WIDTH, FRAME_HEIGHT + 200 + self.menuBar().height())
        self.setMouseTracking(True)
        menubar = self.menuBar()

        self.recording = False
        self.video_writer = None

        self.log_time = 0

        self.label_wafer_type      = QLabel()
        self.label_state_label     = QLabel()
        self.label_target_point    = QLabel()
        self.label_coords          = QLabel()
        self.label_target_degree   = QLabel()
        self.label_angle_error     = QLabel()

        self.language = "en"
        self.texts = {
            "ko": {
                "align": "자동모드",
                "Align": "자동모드",
                "ALGIN": "자동모드",
                "set target": "목표설정",
                "Set_Target": "목표설정",
                "SET_TARGET": "목표설정",
                "SET TARGET": "목표설정",
                "set_target": "목표설정",
                "DEFAULT": "원위치",
                "DEFAULT": "원위치",
                "default": "원위치",
                "Default": "원위치",
                "Angle": "각도",
                "ANGLE": "각도",
                "angle": "각도",
                "random_x_min": "무작위 x 최소 범위",
                "random_x_max": "무작위 x 최대 범위",
                "random_y_min": "무작위 y 최소 범위",
                "random_y_max": "무작위 y 최대 범위",
                "random_angle_min": "무작위 각도 최소 범위",
                "random_angle_max": "무작위 각도 최대 범위",
                "Loop": "반복횟수",
                "Apply": "적용",
                "Reset": "초기화",
                "ROTATION": "회전",
                "Rotation": "회전",
                "Status": "상태",
                "STATUS": "상태",
                "Standby": "대기중",
                "STANDBY": "대기중",
                "standby": "대기중",
                "Start": "시작",
                "started": "시작됨",
                "Help": "도움말",
                "file": "파일",
                "File": "파일",
                "Capture": "사진저장",
                "Exit": "종료",
                "POSITION": "위치이동",
                "Position": "위치이동",
                "Variables": "변수설정",
                "variables": "변수설정",
                "Graph": "그래프",
                "graph": "그래프",
                "Reload": "모델 새로고침",
                "reload": "모델 새로고침",
                "Mode": "모드",
                "Log": "로그",
                "log": "로그",
                "Tool": "도구",
                "Language": "언어",
                "language": "언어",
                "Wafer Type": "웨이퍼 종류",
                "Position_Err": "좌표_오차",
                "Angle_Err": "각도_오차",
                "Click to set Target": "목표지점 설정하세요",
                "POSITION completed": "이동 완료됨",
                "Settings": "설정",
                "Wafer Type": "웨이퍼 종류",
                "Position_Err": "좌표 오차",
                "Target Point": "타겟 좌표",
                "Target Deg.": "목표 각도",
                "Angle_Err": "각도 오차",
                "Status": "상태",
                "ALIGN ACCURACY(%)": "정렬 정확도(%)",
                "ROTATION ACCURACY": "회전 정확도(%)",
                "Target Point": "타겟 좌표",
                "Target Deg.": "목표 각도",
                "Saved as": "저장 위치:",
                "Screenshot": "스크린샷",
                "Apply": "적용",
                "Reset": "초기화",
                "Alignment_Zoom": "확대창",
                "Log Saved": "로그 저장됨",
                "Saved": "저장됨",
                "Error": "오류",
                "Save Error": "저장 오류",
                "Wafer Type": "웨이퍼 종류",
                "Target Point": "타겟 좌표",
                "Position_Err": "좌표_오차",
                "Target Deg.": "목표 각도",
                "Angle_Err": "각도_오차",
                "Standby": "대기중",
                "standby": "대기중",
                "STANDBY": "대기중",
                "Positioning...": "위치이동중...",
                "Defaulting...": "원위치중...",
                "Rotationing...": "회전중...",
                "Click to set Target": "목표지점 설정하세요",
                "POSITION completed": "이동 완료됨",
                "Waiting for next Wafer": "다음 웨이퍼 기다리는중",
                "Align...": "정렬중...",
                "ALIGNING": "정렬중",
                "ROTATING": "회전중",
                "DEFAULT": "원위치중",
                "DEFAULT_1": "원위치_1",
                "DEFAULT_2": "원위치_2",
                "AUTO": "자동모드",
                "MANUAL": "수동모드",
                "Operation Not Allowed": "작업 불가",
                "Recording": "녹화",
                "Recording started": "녹화 시작됨",
                "Recording completed": "녹화 완료됨",
                "English": "영어",
                "Save": "저장",
            },
            "en": {
                "align": "Align",
                "Set Target": "Set Target",
                "DEFAULT": "DEFAULT",
                "angle": "Angle",
                "rotation": "Rotation",
                "auto": "Auto Mode",
                "status": "Status",
                "standby": "Standby",
                "start": "Start",
                "set_target": "Set Target",
                "help": "Help",
                "file": "File",
                "capture": "Capture",
                "exit": "Exit",
                "position": "Position",
                "variables": "Variables",
                "graph": "Graph",
                "reload": "Reload Model",
                "log": "Log",
                "Status": "Status",
                "STANDBY": "STANDBY",
                "ALIGNING": "ALIGNING",
                "ROTATING": "ROTATING",
                "DEFAULT": "DEFAULT",
                "AUTO": "AUTO",
                "MANUAL": "MANUAL",
                "Standby": "Standby",
                "Positioning...": "Positioning...",
                "Rotationing...": "Rotationing...",
                "DEFAULT...": "DEFAULT...",
                "Align...": "Align...",
                "Click to set Target": "Click to set Target",
                "Function": "Function",
                "Settings": "Settings",
                "ALIGN ACCURACY(%)": "ALIGN ACCURACY(%)",
                "ROTATION ACCURACY(%)": "ROTATION ACCURACY(%)",
                "Target Point": "Target Point",
                "Target Deg.": "Target Deg.",
                "Saved as": "Saved as",
                "Save": "Save",
                "Screenshot": "Screenshot",
                "Apply": "Apply",
                "Reset": "Reset",
                "Alignment_Zoom": "Alignment_Zoom",
                "Log Saved": "Log Saved",
                "Saved": "Saved",
                "Error": "Error",
                "Save Error": "Save Error",
                "Recording": "Recording",
                "Recording started": "Recording started",
                "Recording completed": "Recording completed",
                "Auto Mode": "Auto Mode",
                "Manual Mode": "Manual Mode",
                "Idle Mode": "Idlme Mode",
                "한국어": "Korean"
            }
        }
        self.loop_results = []  # [ (loop_idx, pos_acc, rot_acc), ... ] # 루프 결과 저장 변수

        self.file_menu = menubar.addMenu(self.t("File"))
        self.capture_action = QAction(self.t("Capture"), self)
        self.save_all_action = QAction("Save", self, triggered=self.save_all)
        self.exit_action = QAction(self.t("Exit"), self, triggered=self.close)
        self.file_menu.addAction(self.capture_action)
        self.file_menu.addAction(self.save_all_action)
        self.file_menu.addAction(self.exit_action)
        self.capture_action.triggered.connect(self.capture_screenshot)

        self.mode_menu = menubar.addMenu("Mode")
        self.auto_mode_action = QAction("Auto Mode", self, triggered=self.set_auto_mode)
        self.manual_mode_action = QAction("Manual Mode", self, triggered=self.set_manual_mode)
        self.idle_mode_action = QAction("Idle Mode", self, triggered=self.set_idle_mode)  

        self.mode_menu.addAction(self.auto_mode_action)
        self.mode_menu.addAction(self.manual_mode_action)
        self.mode_menu.addAction(self.idle_mode_action)  
        self.update_state("IDLE")
        self.idle_timer = QTimer()
        self.idle_timer.timeout.connect(self.enter_idle_mode)

        self.tool_menu = menubar.addMenu(self.t("Tool"))
        self.reload_action = QAction(self.t("Reload"), self, triggered=self.reload_yolo_model)
        self.log_action = QAction(self.t("Log"), self, triggered=self.toggle_log_window)
        self.record_action = QAction(self.t("Recording"))
        self.record_action.setCheckable(True)
        self.record_action.triggered.connect(self.toggle_recording)
        self.tool_menu.addAction(self.record_action)
        self.tool_menu.addAction(self.reload_action)
        self.tool_menu.addAction(self.log_action)
    
        self.settings_menu = menubar.addMenu(self.t("Settings"))
        self.variables_action = QAction(self.t("Variables"), self, triggered=self.show_variable_tab)
        self.settings_menu.addAction(self.variables_action)
        self.language_menu = QMenu(self.t("Language"), self)
        self.ko_action = QAction("한국어", self)
        self.en_action = QAction("English", self)
        self.language_menu.addAction(self.ko_action)
        self.language_menu.addAction(self.en_action)
        self.settings_menu.addMenu(self.language_menu)
        self.ko_action.triggered.connect(lambda: self.set_language("ko"))
        self.en_action.triggered.connect(lambda: self.set_language("en"))
        
        self.help_action = QAction(self.t("Help"), self)
        self.help_action.triggered.connect(self.show_help_dialog)
        menubar.addAction(self.help_action)
        self.cap = cv2.VideoCapture(CAMERA_INDEX)
        self.cap.set(3, FRAME_WIDTH) 
        self.cap.set(4, FRAME_HEIGHT)

        self.zoom_window = None
        self.log_window = LogWindow() 
        self.rotation_active = False 
        self.warned_once = False 

        self.image_label = QLabel()
        self.image_label.setScaledContents(True)
        self.image_label.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.image_label.setFixedSize(FRAME_WIDTH, FRAME_HEIGHT)
        self.tabs = QTabWidget()
        self.tabs.setTabPosition(QTabWidget.North)
        self.tabs.hide() 
        self.setup_tabs() 
        self.position_accuracy_label = QLabel(self.t("Position Accuracy(%)"))
        self.position_accuracy_value_label = QLabel("0.00%")
        self.position_accuracy_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        self.rotation_accuracy_label = QLabel(self.t("Rotation Accuracy(%)"))
        self.rotation_accuracy_label.setStyleSheet("font-size: 14px; font-weight: bold;")
        self.rotation_accuracy_value_label = QLabel("0.00")

        self.label_wafer_type.setText(self.t("Wafer Type") + ": -")
        self.label_target_point.setText(self.t("Target Point:") + f"\n({Target_Point[0]}, {Target_Point[1]})")
        self.label_coords.setText(self.t("Position_Err") + ":\n" + "(0, 0)")
        self.label_target_degree.setText(self.t("Target Deg.") + f": {Target_degree}°")
        self.label_angle_error.setText(self.t("Angle_Err") + f": 0°")
        for lbl in [
        self.label_wafer_type,
        self.label_state_label,
        self.label_target_point,
        self.label_coords,
        self.label_target_degree,
        self.label_angle_error
        ]:
            lbl.setStyleSheet("font-size: 15px; padding: 10px;")

        status_layout = QGridLayout()
        status_layout.addWidget(self.label_wafer_type, 0, 0)
        status_layout.addWidget(self.label_state_label, 1, 0)
        status_layout.addWidget(self.label_target_point, 0, 1)
        status_layout.addWidget(self.label_coords, 0, 2)
        status_layout.addWidget(self.label_target_degree, 1, 1)
        status_layout.addWidget(self.label_angle_error, 1, 2)
        self.accuracy_widget = QWidget()
        accuracy_layout = QVBoxLayout()
        accuracy_layout.setAlignment(Qt.AlignCenter)   
        accuracy_layout.setSpacing(20)

        accuracy_layout.addWidget(self.position_accuracy_label)
        accuracy_layout.addWidget(self.position_accuracy_value_label)
        accuracy_layout.addSpacing(10)
        accuracy_layout.addWidget(self.rotation_accuracy_label)
        accuracy_layout.addWidget(self.rotation_accuracy_value_label)
        self.accuracy_widget.setLayout(accuracy_layout)
        self.accuracy_widget.setFixedWidth(200)  
        self.status_widget = QWidget()
        self.status_widget.setLayout(status_layout)
        self.status_widget.setFixedWidth(460)
        left_panel = QWidget()
        left_layout = QVBoxLayout()
        left_layout.setContentsMargins(0, 0, 0, 0)
        left_layout.setSpacing(0)
        left_layout.addWidget(self.tabs)
        left_layout.addStretch()
        left_panel.setLayout(left_layout)
        left_panel.setFixedWidth(520)
        bottom_layout = QHBoxLayout()
        bottom_layout.setContentsMargins(0, 0, 0, 0)
        bottom_layout.setSpacing(0)
        bottom_layout.addWidget(left_panel)            
        bottom_layout.addWidget(self.accuracy_widget)  
        bottom_layout.addWidget(self.status_widget)    

        bottom_widget = QWidget()
        bottom_widget.setLayout(bottom_layout)

        main_layout = QVBoxLayout()
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        main_layout.addWidget(self.image_label)
        main_layout.addWidget(bottom_widget)

        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)
        self.initial_offset = (100, 100)
        self.initial_angle = 140
        self.ser_reader = None
        self.ser_writer = None
        self.serial_ready = False
        self.reset_timer = QTimer()
        self.reset_timer.setSingleShot(True)
        self.timer = QTimer()
        self.timer.timeout.connect(self.update_frame)
        self.timer.start(30)

        self.setMouseTracking(True)
        self.show()
        asyncio.create_task(self.serial_setup())
        self.state = "Idle"

    def log_time_limit(self, msg):
        now = time.time()
        if now - self.log_time >= 10:
            self.log_time = now
            log(msg, self)

    def set_idle_mode(self): # 객체 탐지 정지
        self.mode = "IDLE"
        self.tabs.hide()
        self.update_state("IDLE")
        log("[MODE] Entered IDLE Mode", self)

    def set_auto_mode(self): # AUTO 모드, Align tab show
        self.mode = "AUTO"
        self.tabs.clear()
        self.tabs.addTab(self.auto_tab, self.t("Align")) 
        self.update_state("AUTO")
        self.tabs.show()
        self.reset_idle_timer()

    def set_manual_mode(self): # Manual 모드, Position, Rotation tab show
        self.mode = "MANUAL"
        self.update_state("Manual")
        self.tabs.clear()
        self.tabs.addTab(self.position_tab, self.t("Position"))
        self.tabs.addTab(self.rotation_tab, self.t("Rotation"))
        self.tabs.show()
        self.reset_idle_timer()

    def enter_idle_mode(self): # Idle 모드, 수동으로 전환환
        self.mode = "IDLE"
        self.update_state("IDLE")
        self.tabs.hide()
        log("[MODE] Entered IDLE mode", self)

    # def reset_idle_timer(self): # Idle 진입 시간, 추후 serial_command 완료 후, 시간재서 Idle Mode 진입으로
    #     self.idle_timer.start(1200000)  # 1분

    def update_state(self, mode): # 각 모드에 따라서 state 전환
        if mode.upper() == "AUTO":
            self.label_state_label.setText(self.t("Auto"))
        elif mode.upper() == "MANUAL":
            self.label_state_label.setText(self.t("Manual"))
        elif mode.upper() == "IDLE":
            self.label_state_label.setText(self.t("Idle"))

    def toggle_recording(self, checked): # 화면기록 # 수정필요 # camera_frame만 녹화됨됨
        if checked:
            fourcc = cv2.VideoWriter_fourcc(*'mp4v')
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            filename = f"record_{timestamp}.avi"
            self.video_writer = cv2.VideoWriter(
                filename, fourcc, 30.0, (FRAME_WIDTH, FRAME_HEIGHT)
            )
            self.recording = True
            log("[RECORDING] Record started", self)
        else:
            if self.video_writer:
                self.video_writer.release()
                self.video_writer = None
            self.recording = False
            log("[RECORDING] Record completed")

    # def record_screen(duration=1000, filename=None, fps=30):

    #     if filename is None:
    #         timestamp = time.strftime("%Y%m%d_%H%M%S")
    #         filename = f"record_{timestamp}.mp4"

    #     with mss.mss() as sct:
    #         monitor = sct.monitors[1]  # 전체 화면 기준
    #         width, height = monitor['width'], monitor['height']

    #         fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    #         out = cv2.VideoWriter(filename, fourcc, fps, (width, height))

    #         start_time = time.time()
    #         print(f"[RECORDING] Screen recording started: {filename}")

    #         while time.time() - start_time < duration:
    #             img = np.array(sct.grab(monitor))
    #             frame = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
    #             out.write(frame)

    #             # 미리 보기 옵션 (필요시 주석 해제)
    #             # cv2.imshow('Recording', frame)
    #             if cv2.waitKey(1) == 27:  # ESC to stop early
    #                 print("[RECORDING] Stopped manually")
    #                 break

        out.release()
        cv2.destroyAllWindows()
        print(f"[RECORDING] Screen recording saved: {filename}")
        return filename

    def set_language(self, lang):
        self.language = lang
        self.update_all_texts()

    def t(self, key):
        return self.texts[self.language].get(key, key)

    def update_all_texts(self):
        try:
            # 메뉴
            self.file_menu.setTitle(self.t("File"))
            self.capture_action.setText(self.t("Capture"))
            self.save_all_action.setText(self.t("Save"))

            self.exit_action.setText(self.t("Exit"))
            self.auto_mode_action.setText(self.t("Align"))
            self.manual_mode_action.setText(self.t("Position"))
            self.manual_mode_action.setText(self.t("Rotation"))
            self.tool_menu.setTitle(self.t("Tool"))
            self.reload_action.setText(self.t("Reload"))
            self.log_action.setText(self.t("Log"))
            self.settings_menu.setTitle(self.t("Settings"))
            self.variables_action.setText(self.t("Variables"))
            self.language_menu.setTitle(self.t("Language"))
            self.ko_action.setText("한국어")
            self.en_action.setText("English")
            self.help_action.setText(self.t("Help"))
            # 탭
            self.tabs.setTabText(self.tabs.indexOf(self.position_tab), self.t("Position"))
            self.tabs.setTabText(self.tabs.indexOf(self.rotation_tab), self.t("Rotation"))
            self.tabs.setTabText(self.tabs.indexOf(self.variable_tab), self.t("Variables"))
            self.tabs.setTabText(self.tabs.indexOf(self.auto_tab), self.t("Align"))
            # 버튼/라벨
            self.m_button.setText(self.t("SET TARGET"))
            self.s_button.setText(self.t("START"))
            self.u_button.setText(self.t("DEFAULT"))
            self.a_button.setText(self.t("SET TARGET"))
            self.r_button.setText(self.t("START"))
            self.t_button.setText(self.t("Align"))
            self.position_accuracy_value_label.setText(self.t("ALIGN ACCURACY(%)"))
            self.rotation_accuracy_value_label.setText(self.t("ROTATION ACCURACY(%)"))
            self.label_wafer_type.setText(self.t("Wafer Type") + ": -")
            self.label_state_label.setText(self.t("Mode:"))
            self.label_coords.setText(self.t("Position_Err") + ":\n" + "(0, 0)")
            self.label_target_point.setText(self.t("Target Point") + f":\n({Target_Point[0]}, {Target_Point[1]})")
            self.label_target_degree.setText(self.t("Target Deg.") + f":{Target_degree}°")
            self.label_angle_error.setText(self.t("Angle_Err") + f":0°")
        except Exception as e:
            print("update_all_texts 오류:", e)

    def update_target_point_label(self):
        self.label_target_point.setText(self.t("Target Point") + f":\n({Target_Point[0]}, {Target_Point[1]})")

    def apply_auto_var_changes(self):
        try:
            global default_dxdy, Target_Point, Target_degree, auto_loop_count, RANDOM_MODE, random_angle_max, random_angle_min, random_x_max, random_x_min, random_y_max, random_y_min
            default_dxdy     = eval(self.auto_var_fields["default_dxdy"].text())
            Target_Point  = eval(self.auto_var_fields["TARGET_POINT"].text())
            Target_degree = float(self.auto_var_fields["TARGET_DEGREE"].text())
            auto_loop_count = int(self.auto_var_fields["LOOP"].text())
            random_x_min      = int(self.auto_var_fields["random_x_min"].text())
            random_x_max      = int(self.auto_var_fields["random_x_max"].text())
            random_y_min      = int(self.auto_var_fields["random_y_min"].text())
            random_y_max      = int(self.auto_var_fields["random_y_max"].text())
            random_angle_min    = float(self.auto_var_fields["random_angle_min"].text())
            random_angle_max    = float(self.auto_var_fields["random_angle_max"].text())

            RANDOM_MODE = self.random_checkbox.isChecked()

            self.update_target_point_label()
            self.label_target_degree.setText(self.t("Target Deg.") + f":{Target_degree}°")
        except Exception as e:
            show_warning(self, "Apply Error", str(e))

    def reset_auto_var_fields(self):
        self.auto_var_fields["default_dxdy"].setText(str((556, 188)))
        self.auto_var_fields["TARGET_POINT"].setText(str([FRAME_WIDTH // 2, FRAME_HEIGHT // 2]))
        self.auto_var_fields["TARGET_DEGREE"].setText(str(0))
        # 방금 수정한 함수 호출
        self.apply_auto_var_changes()

    def setup_tabs(self):
        # Align 탭
        self.position_tab = QWidget()
        align_layout = QVBoxLayout()
        self.m_button = QPushButton(self.t("SET TARGET"))
        self.s_button = QPushButton(self.t("START"))
        self.u_button = QPushButton(self.t("DEFAULT"))
        for btn in [self.m_button, self.s_button, self.u_button]:
            btn.setFixedHeight(50)
            btn.setFixedWidth(460)
            btn.setStyleSheet("font-size: 20px; padding: 6px;")
            align_layout.addWidget(btn)
        self.position_tab.setLayout(align_layout)
        self.s_button.clicked.connect(self.toggle_send)
        self.m_button.clicked.connect(self.toggle_target_mode)
        self.u_button.clicked.connect(self.default)
        # Angle(회전) 탭
        self.rotation_tab = QWidget()
        angle_layout = QVBoxLayout()
        self.a_button = QPushButton(self.t("SET TARGET"))
        self.r_button = QPushButton(self.t("START"))
        for btn in [self.a_button, self.r_button]:
            btn.setFixedHeight(70)
            btn.setFixedWidth(460)
            btn.setStyleSheet("font-size: 20px; padding: 6px;")
            angle_layout.addWidget(btn)
        self.rotation_tab.setLayout(angle_layout)
        self.a_button.clicked.connect(self.set_target_degree)
        self.r_button.clicked.connect(lambda: asyncio.create_task(self.start_rotation()))
        #Auto 탭
        self.auto_tab = QWidget()

        auto_scroll = QScrollArea()
        auto_scroll.setWidgetResizable(True)

        auto_content = QWidget()
        auto_layout = QVBoxLayout(auto_content)
        auto_layout.setContentsMargins(10, 10, 10, 10)
        auto_layout.setSpacing(20)  

        self.t_button = QPushButton(self.t("ALIGN"))
        self.t_button.setFixedHeight(40)
        self.t_button.clicked.connect(self.start_auto_align)
        auto_layout.addWidget(self.t_button)

        self.random_checkbox = QCheckBox(self.t("RANDOM MODE"))
        auto_layout.addWidget(self.random_checkbox)

        default_values = {
            "default_dxdy": str(default_dxdy),
            "TARGET_POINT": str(Target_Point),
            "TARGET_DEGREE": str(Target_degree),
            "LOOP": str(auto_loop_count),
            "random_x_min": str(random_x_min),
            "random_x_max": str(random_x_max),
            "random_y_min": str(random_y_min),
            "random_y_max": str(random_y_max),
            "random_angle_min": str(random_angle_min),
            "random_angle_max": str(random_angle_max),
        }
        form_layout = QFormLayout()
        self.auto_var_fields = {}
        for key, val in default_values.items():
            label = QLabel(key)
            line_edit = QLineEdit(val)
            self.auto_var_fields[key] = line_edit
            form_layout.addRow(label, line_edit)
        auto_layout.addLayout(form_layout)

        # 6) Apply / Reset 버튼
        apply_btn = QPushButton(self.t("Apply"))
        reset_btn = QPushButton(self.t("Reset"))
        apply_btn.clicked.connect(self.apply_auto_var_changes)
        reset_btn.clicked.connect(self.reset_auto_var_fields)
        btn_box = QHBoxLayout()
        btn_box.addWidget(apply_btn)
        btn_box.addWidget(reset_btn)
        auto_layout.addLayout(btn_box)

        auto_scroll.setWidget(auto_content)

        tab_layout = QVBoxLayout(self.auto_tab)
        tab_layout.setContentsMargins(0,0,0,0)
        tab_layout.addWidget(auto_scroll)

        self.tabs.addTab(self.auto_tab, self.t("Align"))

        self.variable_tab = VariableTab(self) # qustn

    def save_all(self):
        save_path = save_report(self.loop_results)
        pdf_path = make_report_graph_pdf(save_path)
        QMessageBox.information(self, "Saved",
            f"report and graph saved\n{save_path}\n{pdf_path}")

    def start_auto_align(self):
        global auto_mode, rotation_done, position_done
        if send_enabled or self.rotation_active or default_mode:
            log("[ERROR] Cannot start AUTO now", self)
            self.show_warning(self.t("Operation Not Allowed", "AUTO cannot be excuted at this time"))
            return
        self.update_state(self.t("AUTO"))
        rotation_done = position_done = False
        auto_mode = True
        if self.loop and not self.loop.is_closed():
            log("[AUTO] Started", self)
            self.loop.create_task(self.auto_align_loop())
        else:
            log("[ERROR] Event loop is not ready or already closed", self)

    def show_position_tab(self):
        if self.tabs.indexOf(self.position_tab) == -1:
            self.tabs.addTab(self.position_tab, self.t("Position"))
        self.tabs.show()
        self.tabs.setCurrentWidget(self.position_tab)

    def show_rotation_tab(self):
        global position_done, rotation_done
        position_done = rotation_done = False
        if self.tabs.indexOf(self.rotation_tab) == -1:
            self.tabs.addTab(self.rotation_tab, self.t("Rotation"))
        self.tabs.show()
        self.tabs.setCurrentWidget(self.rotation_tab)

    def show_auto_tab(self):
        if self.tabs.indexOf(self.auto_tab) == -1:
            self.tabs.addTab(self.auto_tab, self.t("Align"))
        self.tabs.show()
        self.tabs.setCurrentWidget(self.auto_tab)

    def set_target_degree(self):
        if send_enabled or auto_mode or default_mode or self.rotation_active:
            log("[ERROR] Cannot set TARGET_DEGREE during active operation", self)
            show_warning(self,
                         "Operation Not Allowed",
                         "Cannot set target angle while another operation is in progress.")
            return

        degree, ok = QInputDialog.getDouble(
            self,
            "SETTING",
            "INPUT DEGREE",
            decimals=1,
            min=0,
            max=360
        )
        if not ok:
            return

        global Target_degree
        Target_degree = degree
        log(f"[Angle] Set Target_degree: {Target_degree:.0f}°", self)
        self.label_target_degree.setText(f"Target Deg.: {Target_degree:.0f}°")

    async def serial_setup(self):
        try:
            self.ser_reader, self.ser_writer = await serial_asyncio.open_serial_connection(
                url=SERIAL_PORT, baudrate=BAUDRATE)
            self.serial_ready = True
            log("[INIT] Serial ready", self)
        except Exception as e:
            log(f"[ERR] Serial setup failed: {e}", self)

    async def default_loop(self): # 개선완료
        global confirmed_center, default_mode, dx, dy, send_enabled
        if not confirmed_center:
            return

        default_mode = True
        log("[DEFAULT] DEFAULT started", self)

        MAX_RETRY = 60  
        retry = 0
        while retry < MAX_RETRY:
            await asyncio.sleep(0.5) 
            ret, frame = self.cap.read()
            if not ret:
                continue
            results = model(frame)
            wafer_center = None
            for box in results[0].boxes.data:
                x1, y1, x2, y2, conf, cls = box.tolist()
                label = results[0].names[int(cls)]
                if label in ["P100", "P111"]:
                    cx, cy = int((x1 + x2) / 2), int((y1 + y2) / 2)
                    wafer_center = (cx, cy)
            if wafer_center:
                confirmed_center = wafer_center

            dx, dy, dx_steps, dy_steps, command = calculate_steps(confirmed_center, default_dxdy)
            if abs(dx) + abs(dy) <= 1:
                log(f"[DEFAULT] DEFAULT completed (dx={dx}, dy={dy})", self)
                break

            await self.send_serial_command(command)
            await asyncio.sleep(0.7)  
            retry += 1
        else:
            log("[DEFAULT] DEFAULT Timeout...", self)
        default_mode = False
        await asyncio.sleep(4)
        log("[AUTO] AUTO_Standby ", self)

    async def send_serial_command(self, command):
        global sending_command, awaiting_done, last_sent_command, force_send, default_mode, send_enabled

        if not self.serial_ready or self.ser_writer is None:
            return

        critical_stop = command.upper() in ("STOP", "STOP_ALIGNMENT")
        if (sending_command or awaiting_done) and not critical_stop:
            return
        if command == last_sent_command and not force_send and not critical_stop:
            return

        sending_command = True
        awaiting_done = True

        if default_mode:
            log("[DEFAULT] DEFAULT")
        elif command == "STOP_ALIGNMENT":
            log("[ALIGN] ALIGN stopped", self)
        else:
            actual = command
            if command.upper() == "STOP" or command == "STOP_ALIGNMENT":
                actual = "0,0,0,0,0,0"

            parts = actual.split(",")
            if len(parts) == 6 and (int(parts[4]) != 0 or int(parts[5]) != 0):
                log(f"[ROTATION] Sending ROTATION command: {actual}", self)
            else:
                log(f"[ALIGN] Sending ALIGN command: {actual}", self)

            command = actual

        try:
            self.ser_writer.write((command + "\n").encode())
            await self.ser_writer.drain()
            last_sent_command = command
            force_send = False

            while True:
                try:
                    line = await asyncio.wait_for(self.ser_reader.readline(), timeout=30.0)
                    decoded = line.decode().strip()
                    if "DONE" in decoded or "READY" in decoded:
                        break
                except asyncio.TimeoutError:
                    if default_mode:
                        log("[DEFAULT] TIMEOUT", self)
                    elif command == "STOP_ALIGNMENT":
                        log("[ALIGN] TIMEOUT ", self)
                    break

        except Exception as e:
            log(f"[ERR] Serial communication error: {e}", self)
            log("[ARDUINO] SERIAL_ERROR", self)

        finally:
            sending_command = False
            awaiting_done = False

            if default_mode:
                log("[DEFAULT] DONE", self)
                default_mode = False
                send_enabled = False

            elif last_sent_command == "0,0,0,0,0,0":
                log("[STATUS] STANDBY")
            else:
                parts = last_sent_command.split(",")
                if len(parts) == 6 and (int(parts[4]) != 0 or int(parts[5]) != 0):
                    log("[ROTATION] STEP_DONE", self)
                else:
                    log("[ALIGN] STEP DONE")

    def toggle_log_window(self):
        if self.log_window.isVisible():
            self.log_window.hide()
        else:
            self.log_window.show()
            self.log_window.raise_()

    def toggle_send(self):  # ALIGN 함수
        global send_enabled, stable_count, Target_Point, auto_mode, position_done, rotation_done

        if self.rotation_active or auto_mode or default_mode:
            log("[ERROR] Cannot start ALIGN during other operation", self)
            self.show_warning("Operation Not Allowed", "ALIGN cannot be excuted at this time")
            return # 로그 출력

        if send_enabled:
            send_enabled = False
            asyncio.create_task(self.send_serial_command("STOP_ALIGNMENT"))
            log("[ALIGN] ALIGN stopped", self)
            return

        position_done = rotation_done = False
        send_enabled = True
        auto_mode = False

        log("[ALIGN] ALIGN started", self)
        stable_count = 0
        self.warned_once = False
        if confirmed_center:
            dx0 = abs(Target_Point[0] - confirmed_center[0])
            dy0 = abs(Target_Point[1] - confirmed_center[1])
            self.initial_offset = (dx0, dy0)
        else:
            self.initial_offset = (FRAME_WIDTH, FRAME_HEIGHT)

    async def start_rotation(self):
        global angle, rotation_done
        if send_enabled or auto_mode or default_mode or self.rotation_active:
            log("[ERROR] Cannot start ROTATION during other operation", self)
            self.show_warning("Operation Not Allowed", "Rotation cannot be executed at this time.")
            return

        start_ang = angle
        total = (Target_degree - start_ang) % 360
        if total == 0:
            total = 360
        self.rotation_start = start_ang
        self.rotation_total = total

        rotation_done = False
        self.rotation_active = True
        log("[ROTATION] Rotation started", self)

        while True:
            await asyncio.sleep(0.2)
            ret, frame = self.cap.read()
            if not ret:
                continue
            # ─── YOLO로 F1·웨이퍼 중심 검출 ───
            results = model(frame)
            f1_center = wafer_center = None
            for box in results[0].boxes.data:
                x1, y1, x2, y2, conf, cls = box.tolist()
                label = results[0].names[int(cls)]
                cx, cy = int((x1 + x2) / 2), int((y1 + y2) / 2)
                if label in ["P100", "P111"]:
                    wafer_center = (cx, cy)
                elif label == "F1":
                    f1_center = (cx, cy)
            if not f1_center or not wafer_center:
                log("[DEBUG] Can't find both F1 and wafer center → skipping rotation step", self)
                continue

            angle = calculate_angle(f1_center, wafer_center)
            diff  = (Target_degree - angle + 360) % 360 - 180
            angle_error = abs(diff)

            traveled = (angle - self.rotation_start + 360) % 360
            prog     = min(traveled / self.rotation_total, 1.0) * 100
            self.rotation_accuracy_value_label.setValue(f"{prog:.2f}%")

            self.label_angle_error.setText(f"Angle_Err: {angle_error:.2f}°")
            # ⑤ 완료 판정
            if angle_error < TOLERANCE_R:
                rotation_done = True
                log("[ROTATION] Rotation completed", self)
                await self.send_serial_command("STOP")
                self.rotation_active = False
                self.update_points_after_rotation(frame)
                break
            else:
                # ⑥ 계속 회전 명령
                diR, stR = calculate_rotation(angle, Target_degree)
                command = f"0,0,0,0,{diR},{stR}"
                log(f"[ROTATION] Sending step command: {command}", self)
                await self.send_serial_command(command)

    def update_points_after_rotation(self, frame):
        global confirmed_center
        results = model(frame)
        wafer_center = None
        for box in results[0].boxes.data:
            x1, y1, x2, y2, conf, cls = box.tolist()
            label = results[0].names[int(cls)]
            if label in ["P100", "P111"]:
                cx, cy = int((x1 + x2) / 2), int((y1 + y2) / 2)
                wafer_center = (cx, cy)
        if wafer_center:
            confirmed_center = wafer_center
            log(f"[ROTATION] Updated center: {confirmed_center}", self)

    def reload_yolo_model(self):
        global model
        log("[YOLO] reload model...", self)
        del model
        gc.collect()
        if torch.cuda.is_available():
            torch.cuda.empty_cache()
        model = YOLO("redline.pt")
        log("[YOLO]Successfully reload model", self)

    async def auto_align_loop(self):
        global auto_mode, send_enabled, home_mode, force_send, confirmed_center
        global align_done, rotation_done, auto_loop_count, Target_Point, Target_degree

        log("[AUTO] AUTO started", self)
        auto_mode = True
        count = 0

        while auto_mode and (auto_loop_count == 0 or count < auto_loop_count):
            # ── 랜덤 모드 타겟 설정 ──
            if RANDOM_MODE:
                Target_Point = [
                    random.randint(random_x_min, random_x_max),
                    random.randint(random_y_min, random_y_max)
                ]
                Target_degree = random.uniform(random_angle_min, random_angle_max)
                self.update_target_point_label()
                self.label_target_degree.setText(
                    self.t("Target Deg.") + f": {Target_degree:.1f}°"
                )
                log(f"[AUTO] New random target → Point: {Target_Point}, Degree: {Target_degree:.1f}°", self)
                await asyncio.sleep(0.2)

            # 1) DEFAULT 단계
            if confirmed_center:
                home_mode = True
                log(f"[AUTO] Loop {count+1}: DEFAULT_1 started", self)
                stable_count_default = 0
                retry = 0
                while retry < 200:
                    dx, dy, dx_s, dy_s, cmd = calculate_steps(confirmed_center, default_dxdy)
                    if abs(dx) > TOLERANCE_PX or abs(dy) > TOLERANCE_PX:
                        await self.send_serial_command(cmd)
                        await asyncio.sleep(0.05)
                        retry += 1
                    else:
                        stable_count_default += 1
                        if stable_count_default >= STABLE_REQUIRED:
                            break
                        await asyncio.sleep(0.05)
                log(f"[AUTO] Loop {count+1}): DEFAULT_1 completed ", self)


            # 2) ALIGN 단계
            log(f"[AUTO] Loop {count+1}: [AUTO] ALIGN started", self)
            align_done = False
            stable_count = 0
            if confirmed_center:
                dx0 = abs(Target_Point[0] - confirmed_center[0])
                dy0 = abs(Target_Point[1] - confirmed_center[1])
                self.initial_offset = (dx0, dy0)
            else:
                self.initial_offset = (FRAME_WIDTH, FRAME_HEIGHT)

            position_accuracy_history.clear()
            retry = 0
            while retry < 200:
                await asyncio.sleep(0.05)
                if confirmed_center:
                    dx, dy, dx_s, dy_s, cmd = calculate_steps(confirmed_center, Target_Point)
                    pos_acc = calculate_accuracy_px(Target_Point, confirmed_center)
                    position_accuracy_history.append(pos_acc)
                    self.position_accuracy_value_label.setValue(f"{pos_acc:.2f}%")
                    if abs(dx) > TOLERANCE_PX or abs(dy) > TOLERANCE_PX:
                        await self.send_serial_command(cmd)
                    else:
                        stable_count += 1
                        if stable_count >= STABLE_REQUIRED:
                            align_done = True
                            break
                retry += 1

            await self.send_serial_command("STOP_ALIGN")
            log(f"[AUTO] Loop {count+1}: ALIGN done", self)
            await asyncio.sleep(3.0)

            # 3) ROTATION 단계
            log(f"[AUTO] Loop {count+1}: ROTATION", self)
            rotation_done = False
            self.rotation_active = True
            final_rot_acc = 0.0
            final_angle_err = 0.0

            while True:
                await asyncio.sleep(0.2)
                ret, frame = self.cap.read()
                if not ret:
                    continue

                results = model(frame)
                f1_c = wafer_c = None
                for b in results[0].boxes.data:
                    x1, y1, x2, y2, *_ = b.tolist()
                    lbl = results[0].names[int(b[5])]
                    cx, cy = int((x1 + x2)/2), int((y1 + y2)/2)
                    if lbl in ["P100", "P111"]:
                        wafer_c = (cx, cy)
                    elif lbl == "F1":
                        f1_c = (cx, cy)
                if not f1_c or not wafer_c:
                    continue

                cur_ang = calculate_angle(f1_c, wafer_c)
                diff = (Target_degree - cur_ang + 540) % 360 - 180
                angle_err = abs(diff)
                rot_acc = calculate_rotation_accuracy(angle_err)

                self.rotation_accuracy_value_label.setValue(int(rot_acc))

                if angle_err < TOLERANCE_R:
                    final_rot_acc = rot_acc
                    final_angle_err = angle_err
                    await self.send_serial_command("STOP")
                    self.rotation_active = False
                    self.update_points_after_rotation(frame)
                    rotation_done = True
                    break
                else:
                    diR, stR = calculate_rotation(angle, Target_degree)
                    cmd = f"0,0,0,0,{diR},{stR}"
                    await self.send_serial_command(cmd)

            final_pos_acc = position_accuracy_history[-1] if position_accuracy_history else 0.0
            final_dx = Target_Point[0] - confirmed_center[0] if confirmed_center else 0
            final_dy = Target_Point[1] - confirmed_center[1] if confirmed_center else 0

            counts = [
                len(detection_stats["P100"]["F1"]), len(detection_stats["P100"]["F2"]),
                len(detection_stats["P100"]["P100"]), len(detection_stats["P100"]["P111"]),
                len(detection_stats["P111"]["F1"]), len(detection_stats["P111"]["F2"]),
                len(detection_stats["P111"]["P100"]), len(detection_stats["P111"]["P111"])
            ]

            self.loop_results.append([
                count + 1,
                final_pos_acc,
                final_dx,
                final_dy,
                final_rot_acc,
                final_angle_err,
                *counts
            ])
            log(f"[AUTO] Loop {count+1} result → "
                f"PosAcc={final_pos_acc:.2f}%, ΔX={final_dx}, ΔY={final_dy}, "
                f"RotAcc={final_rot_acc:.2f}%, RotErr={final_angle_err:.2f}°", self)

            await asyncio.sleep(3.0)

            # 4) FINAL DEFAULT
            if confirmed_center:
                log(f"[AUTO] Loop {count+1}: DEFAULT_2 started ", self)
                home_mode = True
                stable_count_default = 0
                retry = 0
                while retry < 200:
                    dx, dy, dx_s, dy_s, cmd = calculate_steps(confirmed_center, default_dxdy)
                    if abs(dx) > TOLERANCE_PX or abs(dy) > TOLERANCE_PX:
                        await self.send_serial_command(cmd)
                        await asyncio.sleep(0.05)
                        retry += 1
                    else:
                        stable_count_default += 1
                        if stable_count_default >= STABLE_REQUIRED:
                            break
                        await asyncio.sleep(0.05)
                log(f"[AUTO] Loop {count+1}: DEFAULT_2 completed ", self)


            count += 1

        auto_mode = False
        send_enabled = False
        force_send = False
        log("[AUTO] AUTO_PAUSED", self)

    def toggle_target_mode(self):
        global setting_target_mode, align_done, rotation_done, Target_Point
        align_done = rotation_done = False

        if not setting_target_mode:
            setting_target_mode = True
            log("[TARGET] Click to TARGET", self)
            self.label_state.setText(self.t("Status") + ": " + self.t("MANUAL"))
        else:
            setting_target_mode = False
            Target_Point = [FRAME_WIDTH // 2, FRAME_HEIGHT // 2]
            log(f"[TARGET] TARGET_POINT reset to center → {Target_Point}", self)
            self.label_state.setText(self.t("Status") + ": " + self.t("STANDBY"))
            self.update_target_point_label()

    def toggle_target_mode(self):
        global setting_target_mode, position_done, rotation_done, Target_Point
        position_done = rotation_done = False

        if not setting_target_mode:
            setting_target_mode = True
            log("[TARGET] Click to set TARGET_POINT", self)
        else:
            setting_target_mode = False
            Target_Point = [FRAME_WIDTH // 2, FRAME_HEIGHT // 2]
            log(f"[TARGET] TARGET_POINT reset to center → {Target_Point}", self)
            self.update_target_point_label()

    def default(self):
        global confirmed_center, default_mode, send_enabled, position_done, rotation_done

        position_done = rotation_done = False

        if not confirmed_center \
        or awaiting_done or sending_command \
        or send_enabled or auto_mode \
        or self.rotation_active:
            return

        default_mode = True
        log("[DEFAULT] DEFAULT started", self)

        dx, dy, dx_steps, dy_steps, command = calculate_steps(confirmed_center, default_dxdy)
        if dx_steps + dy_steps < 10:
            log("[DEFAULT] DEFAULT skipped", self)
            send_enabled = False
        else:
            asyncio.create_task(self.send_serial_command(command))
            log(f"[DEFAULT] Send command: {command}", self)

        asyncio.create_task(self.default_loop())

    def mousePressEvent(self, event):
        global Target_Point, setting_target_mode, last_sent_command, force_send, confirmed_center, send_enabled

        if setting_target_mode and event.button() == Qt.LeftButton:
            pos = event.pos()
            widget_pos = self.image_label.mapFrom(self, pos)
            x = widget_pos.x()
            y = widget_pos.y()

            if 0 <= x < self.image_label.width() and 0 <= y < self.image_label.height():
                Target_Point = [int(x), int(y)]
                self.update_target_point_label()
                log(f"[TARGET] TARGET_POINT set → {Target_Point}", self)

                last_sent_command = ""
                force_send = True
                setting_target_mode = False
                send_enabled = False

    def reset(self):
        global confirmed_center, stable_count, last_sent_command
        confirmed_center = None
        stable_count = 0
        last_sent_command = ""

    def update_frame(self):
        global confirmed_center, stable_count, angle, send_enabled, Target_Point, \
            default_mode, awaiting_done, sending_command, \
            has_f1, has_f2, Target_degree, position_done, rotation_done, force_send
        dx = dy = 0
        command = None

        if send_enabled and not confirmed_center:
            log("[DEBUG] 현재 confirmed_center 없음, 명령 대기중", self)

        if not self.serial_ready:
            return

        if sending_command or awaiting_done:
            return

        if position_done:
            self.position_accuracy_value_label.setText("0.00%")

        ret, frame = self.cap.read()
        if not ret:
            if not self.warned_once:
                log("[CAMERA] Received failed to frame", self)
                self.warned_once = True
        if self.mode == "IDLE":
            display = frame.copy()
            rgb = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
            h, w, ch = rgb.shape
            img = QImage(rgb.data, w, h, ch * w, QImage.Format_RGB888)
            pixmap = QPixmap.fromImage(img)
            self.image_label.setPixmap(pixmap)
            return

        display = frame.copy()
        results = model(display, conf=0.4)
        gray = cv2.cvtColor(display, cv2.COLOR_BGR2GRAY)
        display = cv2.cvtColor(gray, cv2.COLOR_GRAY2BGR)

        wafer_center = f1_center = None
        has_f1 = has_f2 = False

        for box in results[0].boxes.data:
            x1, y1, x2, y2, conf, cls = box.tolist()
            label = results[0].names[int(cls)]
            cx = int((x1 + x2) / 2)
            cy = int((y1 + y2) / 2)

            if label in ["P100", "P111"]:
                wafer_center = (cx, cy)
            elif label == "F1":
                f1_center = (cx, cy)
                has_f1 = True
            elif label == "F2":
                has_f2 = True

        wafer_type = None
        if has_f1 and has_f2:
            wafer_type = "P100"
        elif has_f1:
            wafer_type = "P111"

        self.label_wafer_type.setText(self.t("Wafer Type") + ": " + str(wafer_type or "-"))
        draw_yolo_boxes(display, results, self, wafer_type)

        if wafer_center:
            confirmed_center = wafer_center
        else:
            confirmed_center = None

        if f1_center and wafer_center:
            current_angle = calculate_angle(f1_center, wafer_center)
            angle = current_angle
            diff = (Target_degree - current_angle + 540) % 360 - 180
            angle_error_val = abs(diff)
            self.label_angle_error.setText(self.t("Angle_Err") + f": {angle_error_val:.2f}°")
            cv2.putText(display, f"{current_angle:.0f}deg.", (f1_center[0] + 10, f1_center[1] - 10),
                        FONT, FONT_SCALE, (0, 255, 255), FONT_THICKNESS)

        if confirmed_center:
            dx, dy, dx_steps, dy_steps, command = calculate_steps(confirmed_center, Target_Point)
            self.label_coords.setText(self.t("Position_Err") + f":\n({dx}, {dy})")

            if abs(dx) <= TOLERANCE_PX and abs(dy) <= TOLERANCE_PX:
                if send_enabled and not awaiting_done and not sending_command:
                    stable_count += 1
                    if stable_count >= STABLE_REQUIRED:
                        position_done = True
                        send_enabled = False
                        stable_count = 0
                        asyncio.create_task(self.send_serial_command("STOP_ALIGN"))

                        # 정확도 계산 
                        dx0, dy0 = self.initial_offset
                        dx1 = abs(Target_Point[0] - confirmed_center[0])
                        dy1 = abs(Target_Point[1] - confirmed_center[1])
                        initial_dist = math.sqrt(dx0 ** 2 + dy0 ** 2)
                        final_dist = math.sqrt(dx1 ** 2 + dy1 ** 2)
                        if initial_dist == 0:
                            acc = 100.0 if final_dist == 0 else 0.0
                        else:
                            acc = max(0.0, min((1 - final_dist / initial_dist) * 100, 100.0))
                        self.position_accuracy_value_label.setText(f"{acc:.2f}%")
                        return
            else:
                stable_count = 0

            if send_enabled \
                and stable_count < STABLE_REQUIRED \
                and not awaiting_done and not sending_command \
                and command is not None \
                and (command != last_sent_command or force_send):
                    asyncio.create_task(self.send_serial_command(command))
                    force_send = False
        else:
            self.label_coords.setText(self.t("Position_Err") + ": -")

        # 타겟 점, 현재 점 표시
        if not self.rotation_active and not default_mode:
            cv2.circle(display, tuple(Target_Point), 5, (0, 0, 255), -1)
            if confirmed_center:
                cv2.circle(display, confirmed_center, 5, (0, 255, 0), -1)
                cv2.line(display, tuple(Target_Point), confirmed_center, (255, 0, 0), 2)

        rgb = cv2.cvtColor(display, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb.shape
        img = QImage(rgb.data, w, h, ch * w, QImage.Format_RGB888)
        pixmap = QPixmap.fromImage(img)
        self.image_label.setPixmap(pixmap)
    
    def keyPressEvent(self, event):
        key = event.key()
        if key == Qt.Key_F1:
            self.capture_action # F1 누르면 캡쳐
        elif key == Qt.Key_F2:
            self.record_action # F2 누르면 녹화

    def capture_screenshot(self):
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        filename = f"screenshot_{timestamp}.png"
        pixmap = self.grab()
        pixmap.save(filename)
        QMessageBox.information(self, self.t("Screenshot"), self.t(f"Saved as {filename}"))

    def show_help_dialog(self):
        msg = QMessageBox(self)
        msg.setIcon(QMessageBox.Information)
        msg.setWindowTitle("도움말")
        msg.setText("추후 기재") # 수정
        msg.exec_()

    def show_variable_tab(self):
        if self.tabs.indexOf(self.variable_tab) == -1:
            self.tabs.addTab(self.variable_tab, "Variables")
        self.tabs.show()
        self.tabs.setCurrentWidget(self.variable_tab)

    def toggle_zoom_window(self):
        if self.zoom_window is None:
            self.zoom_window = ZoomWindow()
        else:
            self.zoom_window.show()
            self.zoom_window.raise_()

class LogWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Log")
        self.setGeometry(200, 200, 600, 400)
        self.logs = []
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.filter_box = QComboBox()
        self.filter_box.addItems(["ALL", "ALIGN", "ROTATION", "CHANGED", "ERROR", "Status"]) #추후에 추가
        self.filter_box.currentTextChanged.connect(self.apply_filter)
        layout = QVBoxLayout()
        layout.addWidget(self.filter_box)
        layout.addWidget(self.text_edit)
        self.setLayout(layout)
    
    def append_log(self, msg):
        self.logs.append(msg)
        self.apply_filter()

    def apply_filter(self):
        selected = self.filter_box.currentText()
        self.text_edit.clear()
        for msg in self.logs:
            if selected == "ALL" or f"[{selected}]" in msg:
                self.text_edit.append(msg)
        self.text_edit.verticalScrollBar().setValue(
            self.text_edit.verticalScrollBar().maximum()
        )

class VariableTab(QWidget):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.default_values = {
            "default_dxdy": "(556, 188)", # default_dxdy 먼저 수정
            "Target_Point": "[640, 360]",
            "PIXEL_TO_STEP": "{'x': 33.0, 'y': 45.65}", 
            "TOLERANCE_PX": "1",
            "TOLERANCE_R": "1",
            "MAX_STEPS": "32000",
        }
        self.fields = {}
        layout = QVBoxLayout()
        form_layout = QFormLayout()

        for key, value in self.default_values.items():
            label = QLabel(key)
            line_edit = QLineEdit()
            line_edit.setText(value)
            self.fields[key] = line_edit
            form_layout.addRow(label, line_edit)

        apply_button = QPushButton(self.main_window.t("Apply"))
        apply_button.clicked.connect(self.apply_changes)
        reset_button = QPushButton(self.main_window.t("Reset"))
        reset_button.clicked.connect(self.reset_fields)

        layout.addLayout(form_layout)
        layout.addWidget(apply_button)
        layout.addWidget(reset_button)

        scroll_area = QScrollArea()
        container = QWidget()
        container.setLayout(layout)
        scroll_area.setWidget(container)
        scroll_area.setWidgetResizable(True)

        scroll_layout = QVBoxLayout()
        scroll_layout.addWidget(scroll_area)
        self.setLayout(scroll_layout)

    def apply_changes(self):
        try:
            changes = [] # 변수변경내역저장

            def update_variable(name, parse_func):
                old_val = str(globals()[name])
                new_val = parse_func(self.fields[name].text())
                if str(new_val) != old_val:
                    globals()[name] = new_val
                    changes.append(f"{name} changed from {old_val} to {new_val}.")
                    if name == "Target_Point":
                        self.main_window.update_target_point_label()
            update_variable("default_dxdy", eval)
            update_variable("Target_Point", eval)
            update_variable("PIXEL_TO_STEP", eval)
            update_variable("TOLERANCE_PX", int)
            update_variable("TOLERANCE_R", int,)
            update_variable("MAX_STEPS", int)

            for msg in changes:
                log(f"[CHANGED] {msg}", self.main_window)
        except Exception as e:
            print(f"[ERROR] Failed to apply changes: {e}")

    def reset_fields(self):
        for key, default_val in self.default_values.items():
            self.fields[key].setText(default_val)
        self.apply_changes()

class ZoomWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(self.t("Point_Zoom"))
        self.setFixedSize(600, 400)
        self.zoom_label = QLabel()
        self.zoom_label.setScaledContents(True)
        layout = QVBoxLayout()
        layout.addWidget(self.zoom_label)
        self.setLayout(layout)
        self.show()

    def update_zoom(self, image):
        h, w, ch = image.shape
        qimg = QImage(image.data, w, h, ch * w, QImage.Format_RGB888)
        qimg = qimg.rgbSwapped()
        self.zoom_label.setPixmap(QPixmap.fromImage(qimg))

    def append_log(self, msg):
        timestamp = time.strftime("[%Y-%m-%d]", time.localtime())
        self.text_edit.append(timestamp + msg)
        self.text_edit.verticalScrollBar().setValue(self.text_edit.verticalScrollBar().maximum())

    def save_log(self):
        try:
            now = time.strftime("%Y%m%d_%H%M%S")
            filename = f"log_{now}.txt"
            with open(filename, "w", encoding="utf-8") as f:
                f.write(self.text_edit.toPlainText())
            QMessageBox.information(self, "Log Saved", f"Saved as {filename}")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Failed to save log: {e}")

def main():
    app = QApplication(sys.argv)
    splash_pix = QPixmap("C:/Users/Mai/Desktop/wafer_project/splash.png").scaled(
        1400, 576, Qt.KeepAspectRatio, Qt.SmoothTransformation
    )
    splash = QSplashScreen(splash_pix)
    splash.show()
    app.processEvents()
    loop = QEventLoop(app)              
    asyncio.set_event_loop(loop)      
    def start_main_program():
        splash.close()
        window = MainWindow(loop)      
        window.loop = loop              
        window.serial_ready = True     
    QTimer.singleShot(3000, start_main_program)
    with loop:
        loop.run_forever()            
if __name__ == "__main__":
    main()
